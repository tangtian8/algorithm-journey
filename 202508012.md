# 20250812

### 01背包

有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

#### 携带研究材料（第六期模拟笔试）

###### 题目描述

小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的空间，并且具有不同的价值。 

小明的行李空间为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料只能选择一次，并且只有选与不选两种选择，不能进行切割。

###### 输入描述

第一行包含两个正整数，第一个整数 M 代表研究材料的种类，第二个正整数 N，代表小明的行李空间。

第二行包含 M 个正整数，代表每种研究材料的所占空间。 

第三行包含 M 个正整数，代表每种研究材料的价值。

###### 输出描述

输出一个整数，代表小明能够携带的研究材料的最大价值。

###### 输入示例

```
6 1
2 2 3 1 5 2
2 3 1 5 4 3
```

###### 输出示例

```
5
```

###### 提示信息

小明能够携带 6 种研究材料，但是行李空间只有 1，而占用空间为 1 的研究材料价值为 5，所以最终答案输出 5。 

数据范围：
1 <= N <= 5000
1 <= M <= 5000
研究材料占用空间和价值都小于等于 1000

#### 二维dp数组01背包
```javascripts
二维数组为 dp[i][j]
i 来表示物品、j表示背包容量。
dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
```

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int bagweight = scanner.nextInt();

        int[] weight = new int[n];
        int[] value = new int[n];

        for (int i = 0; i < n; ++i) {
            weight[i] = scanner.nextInt();
        }
        for (int j = 0; j < n; ++j) {
            value[j] = scanner.nextInt();
        }

        int[][] dp = new int[n][bagweight + 1];

        for (int j = weight[0]; j <= bagweight; j++) {
            dp[0][j] = value[0];
        }

        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= bagweight; j++) {
                if (j < weight[i]) {
                    dp[i][j] = dp[i - 1][j];
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
                }
            }
        }

        System.out.println(dp[n - 1][bagweight]);
    }
}
```

#### 一维dp数组01背包

```javascript
一维dp数组，其实就上上一层 dp[i-1] 这一层 拷贝的 dp[i]来。

dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
```

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 读取 M 和 N
        int M = scanner.nextInt();  // 研究材料的数量
        int N = scanner.nextInt();  // 行李空间的大小

        int[] costs = new int[M];   // 每种材料的空间占用
        int[] values = new int[M];  // 每种材料的价值

        // 输入每种材料的空间占用
        for (int i = 0; i < M; i++) {
            costs[i] = scanner.nextInt();
        }

        // 输入每种材料的价值
        for (int j = 0; j < M; j++) {
            values[j] = scanner.nextInt();
        }

        // 创建一个动态规划数组 dp，初始值为 0
        int[] dp = new int[N + 1];

        // 外层循环遍历每个类型的研究材料
        for (int i = 0; i < M; i++) {
            // 内层循环从 N 空间逐渐减少到当前研究材料所占空间
            for (int j = N; j >= costs[i]; j--) {
                // 考虑当前研究材料选择和不选择的情况，选择最大值
                dp[j] = Math.max(dp[j], dp[j - costs[i]] + values[i]);
            }
        }

        // 输出 dp[N]，即在给定 N 行李空间可以携带的研究材料的最大价值
        System.out.println(dp[N]);

        scanner.close();
    }
}

```

#### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)



给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

 

**示例 1：**

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

**示例 2：**

```
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

 

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`

```java
class Solution {
   public boolean canPartition(int[] nums) {
       int len = nums.length;
       int sum = 0;
       
       // 计算数组所有元素的总和
       for(int n : nums){
           sum = n + sum;
       } 
       
       // 如果总和是奇数，不可能平分成两个相等的子集
       if((sum & 1) == 1){
           return false;
       }

       // 目标值是总和的一半，如果能找到子集和等于target，剩余元素和也等于target
       int target = sum / 2;
       
       // dp[i][j] 表示使用前i个元素能否组成和为j的子集
       // i的范围是[0, len-1]，j的范围是[0, target]
       boolean[][] dp = new boolean[len][target + 1];
       
       // 初始化第一行：只使用第一个元素nums[0]
       for(int j = 0; j <= target; j++){
           dp[0][j] = (nums[0] == j);
       }
       
       // 填充dp表格，从第二个元素开始
       for(int i = 1; i < len; i++){
           for(int j = 0; j <= target; j++){
               // 不选择当前元素nums[i]，继承上一行的结果
               dp[i][j] = dp[i - 1][j];
               
               // 如果当前元素值正好等于目标和j，可以单独组成
               if(nums[i] == j){
                   dp[i][j] = true;
                   continue;
               }
               
               // 如果当前元素小于目标和j，可以选择加入
               // dp[i-1][j-nums[i]] 表示用前i-1个元素能否组成 j-nums[i] 的和
               // 如果可以，那么加上当前元素nums[i]就能组成和j
               if(nums[i] < j){
                   dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];
               }
           }
       } 
       
       // 返回使用所有元素能否组成target的结果
       return dp[len - 1][target];
   }
}
```

