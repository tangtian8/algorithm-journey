# 20250805

#### [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 *你能获得的 **最大** 利润* 。

 

**示例 1：**

```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。
最大总利润为 4 + 3 = 7 。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
最大总利润为 4 。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0。
```

 

**提示：**

- `1 <= prices.length <= 3 * 104`
- `0 <= prices[i] <= 104`

##### 实现

```java
class Solution {
    public int maxProfit(int[] prices) {
        int res = 0;
        for( int i = 0; i < prices.length - 1 ;i++){
            if(prices[i + 1]- prices[i] > 0){
                res = res + prices[i + 1]- prices[i];
            }
        }
        return res;
    }
}
```

#### [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**示例 2：**

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

 

**提示：**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 105`

##### 实现

```java
class Solution {
    public boolean canJump(int[] nums) {
       // rightMost 记录当前能够跳跃到达的最远位置索引
        int rightMost = 0;
        
        // 遍历数组中的每个位置
        for(int i = 0; i < nums.length; i++){
            // 只有当前位置 i 在可达范围内时，才考虑从该位置跳跃
            if(i <= rightMost){
                // 更新最远可达位置：当前最远位置 vs 从位置i能跳到的最远位置
                // nums[i] 表示在位置 i 最多可以跳跃的步数
                rightMost = Math.max(rightMost, i + nums[i]);
                
                // 如果最远可达位置已经覆盖或超过了最后一个索引，说明可以到达终点
                if(rightMost >= nums.length - 1){
                    return true;
                }
            }
            // 如果当前位置 i 超出了可达范围 (i > rightMost)，
            // 说明无法到达位置 i，也就无法继续向前跳跃
        }
        
        // 遍历完所有位置都无法到达终点
        return false;
    }
}
```

#### [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向后跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]` 
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

 

**示例 1:**

```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

**示例 2:**

```
输入: nums = [2,3,0,1,4]
输出: 2
```

 

**提示:**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 1000`
- 题目保证可以到达 `nums[n-1]`

##### 实现

```java
class Solution {
    public int jump(int[] nums) {
 // position表示当前需要到达的目标位置，初始为最后一个位置
        int position = nums.length - 1;
        
        // steps记录跳跃次数
        int steps = 0;
        
        // 当目标位置不是起始位置时继续循环
        while(position > 0){
            // 从数组开始位置遍历到当前目标位置之前
            for(int i = 0; i < position; i++){
                // 检查从位置i是否能够跳跃到当前目标位置
                // i + nums[i] 表示从位置i能够到达的最远位置
                if(i + nums[i] >= position){
                    // 如果能够到达，则将位置i设为新的目标位置
                    // 这样做的原因是：我们要找能到达当前position的最远的起始位置
                    // 这样可以最大化每一步的跳跃距离，从而最小化总步数
                    position = i;
                    
                    // 步数增加1
                    steps++;
                    
                    // 找到第一个能到达的位置就跳出，因为这是最远的位置
                    break;
                }
            }
        }
        
        // 返回总的跳跃步数
        return steps;
    }
}
```

#### [1005. K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)

给你一个整数数组 `nums` 和一个整数 `k` ，按以下方法修改该数组：

- 选择某个下标 `i` 并将 `nums[i]` 替换为 `-nums[i]` 。

重复这个过程恰好 `k` 次。可以多次选择同一个下标 `i` 。

以这种方式修改数组后，返回数组 **可能的最大和** 。

 

**示例 1：**

```
输入：nums = [4,2,3], k = 1
输出：5
解释：选择下标 1 ，nums 变为 [4,-2,3] 。
```

**示例 2：**

```
输入：nums = [3,-1,0,2], k = 3
输出：6
解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。
```

**示例 3：**

```
输入：nums = [2,-3,-1,5,-4], k = 2
输出：13
解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。
```

 

**提示：**

- `1 <= nums.length <= 104`
- `-100 <= nums[i] <= 100`
- `1 <= k <= 104`

##### 实现

```java
class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) {
        Arrays.sort(nums);
        int res = 0;
        for(int i = 0; i < nums.length; i++){
            if(nums[i] < 0 && k > 0){
                nums[i] = -1 * nums[i];
                k--;
            }
            res = res + nums[i];
        }

        Arrays.sort(nums);
      //k % 2 这个太好了
        return res - (k % 2 == 0 ? 0 : 2* nums[0]);
    }
}
```

