# 20250820

#### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

 

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

 

**提示：**

- `1 <= nums.length <= 2500`
- `-104 <= nums[i] <= 104`

 

**进阶：**

- 你能将算法的时间复杂度降低到 `O(n log(n))` 吗?

##### 实现

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int[] dp = new int[nums.length];
        dp[0] = 1;
        int maxans = 1;
        for (int i = 1; i < nums.length; i++) {
            dp[i] = 1;
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }

            }
            maxans = Math.max(maxans, dp[i]);
        }
        return maxans;
    }

}
```

#### [674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

给定一个未经排序的整数数组，找到最长且 **连续递增的子序列**，并返回该序列的长度。

**连续递增的子序列** 可以由两个下标 `l` 和 `r`（`l < r`）确定，如果对于每个 `l <= i < r`，都有 `nums[i] < nums[i + 1]` ，那么子序列 `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` 就是连续递增子序列。

 

**示例 1：**

```
输入：nums = [1,3,5,4,7]
输出：3
解释：最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 
```

**示例 2：**

```
输入：nums = [2,2,2,2,2]
输出：1
解释：最长连续递增序列是 [2], 长度为1。
```

 

**提示：**

- `1 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`

##### 实现

```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        /* 判断 */
        if(nums.length <= 1) return nums.length;
        
        /* 定义记录结果的变量 */
        int result = 0;
        
        /* 定义dp数组并初始化为1 */
        int[] dp = new int[nums.length + 1];
        Arrays.fill(dp, 1);
        
        /* 遍历 */
        for(int i = 1; i < nums.length; i++) {
            if(nums[i-1] < nums[i]) {
                /* 不连续递增子序列的跟前0-i 个状态有关，连续递增的子序列只跟前一个状态有关 */
                dp[i] = dp[i-1] + 1;
            }
            /* 记录dp数组中的最大值 */
            if(result < dp[i]) result = dp[i];
        }
        
        return result;
    }
}
```
#### [718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

给两个整数数组 `nums1` 和 `nums2` ，返回 *两个数组中 **公共的** 、长度最长的子数组的长度* 。

 

**示例 1：**

```
输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
输出：3
解释：长度最长的公共子数组是 [3,2,1] 。
```

**示例 2：**

```
输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
输出：5
```

 

**提示：**

- `1 <= nums1.length, nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 100`

##### 实现

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
       int n = nums1.length;
       int m = nums2.length;
       int ans = 0;
       int[][] dp = new int[n+1][m+1];
       for(int i = n - 1;i >=0 ;i --){
        for(int j = m - 1; j >= 0; j--){
            dp[i][j] = nums1[i] == nums2[j] ? dp[i + 1][j + 1] + 1 : 0;
            ans = Math.max(ans,dp[i][j]);
        }
       }
       return ans;
    }
}
```



