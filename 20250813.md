# 20250813

#### [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)

有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。

 

**示例 1：**

```
输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
```

**示例 2：**

```
输入：stones = [31,26,33,21,40]
输出：5
```

 

**提示：**

- `1 <= stones.length <= 30`
- `1 <= stones[i] <= 100`

##### 思路
将石头分为两堆，使得两堆重量尽可能接近
使用0-1背包的思想，找出能组成的最接近总重量一半的重量
最终答案就是两堆重量的差值

算法的时间复杂度是 O(n × sum/2)，空间复杂度是 O(n × sum/2)，其中 n 是石头数量，sum 是所有石头的总重量。

##### 实现

```java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        // 计算所有石头的总重量
        int sum = 0;
        for(int weight : stones){
            sum = sum + weight;
        }

        int n = stones.length;  // 石头数量
        int m = sum / 2;        // 目标重量（总重量的一半）
        
        // dp[i][j] 表示前i个石头是否能组成重量j
        // i的范围是[0, n]，j的范围是[0, m]
        boolean[][] dp = new boolean[n+1][m + 1];
        
        // 初始化：0个石头可以组成重量0
        dp[0][0] = true;
        
        // 动态规划：对每个石头进行选择
        for(int i = 0; i < n; i++){
            for(int j = 0; j <= m; j++){
                if(j < stones[i]){
                    // 当前重量j小于石头重量，无法选择当前石头
                    dp[i+1][j] = dp[i][j];
                } else {
                    // 当前重量j >= 石头重量，可以选择或不选择当前石头
                    // dp[i][j]: 不选择当前石头
                    // dp[i][j - stones[i]]: 选择当前石头
                    dp[i+1][j] = dp[i][j] || dp[i][j - stones[i]];
                }
            }
        }
        
        // 从m开始向下寻找最大的可达成重量
        // 这样能保证两堆石头的重量差最小
        for(int j = m; ; j--){
            if(dp[n][j]){
                // 如果一堆重量为j，另一堆重量为(sum-j)
                // 两堆重量差为：(sum-j) - j = sum - 2*j
                return sum - 2 * j;
            }
        }
    }
}
```

#### [494. 目标和](https://leetcode.cn/problems/target-sum/)

给你一个非负整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

 

**示例 1：**

```
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

**示例 2：**

```
输入：nums = [1], target = 1
输出：1
```

 

**提示：**

- `1 <= nums.length <= 20`
- `0 <= nums[i] <= 1000`
- `0 <= sum(nums[i]) <= 1000`
- `-1000 <= target <= 1000`

##### 实现

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        // 计算数组所有元素的总和
        int sum = 0;
        for(int num : nums) {
            sum = sum + num;
        }
        
        // 核心思路转换：
        // 假设添加正号的元素和为P，添加负号的元素和为N
        // 则有：P - N = target 且 P + N = sum
        // 解得：P = (sum + target) / 2, N = (sum - target) / 2
        // 问题转换为：在数组中选择一些数字，使其和等于N
        
        int diff = sum - target;  // diff = 2 * N
        
        // 边界条件检查：
        // 1. 如果sum < target，无解
        // 2. 如果(sum - target)为奇数，说明无法整除2，无解
        if(diff < 0 || diff % 2 != 0) {
            return 0;
        }
        
        int n = nums.length;
        int neg = diff / 2;  // 需要添加负号的元素的目标和
        
        // dp[i][j] 表示：使用前i个数字，能组成和为j的方案数
        int[][] dp = new int[n + 1][neg + 1];
        
        // 初始化：使用0个数字组成和为0的方案数为1（什么都不选）
        dp[0][0] = 1;
        
        // 动态规划填表
        for(int i = 1; i <= n; i++) {
            int num = nums[i - 1];  // 当前考虑的数字
            
            for(int j = 0; j <= neg; j++) {
                // 不选择当前数字num的方案数
                dp[i][j] = dp[i - 1][j];
                
                // 如果当前目标和j >= num，可以选择当前数字
                if(j >= num) {
                    // 选择当前数字num的方案数
                    dp[i][j] += dp[i - 1][j - num];
                }
            }
        }
        
        // 返回使用所有n个数字，组成和为neg的方案数
        return dp[n][neg];
    }
}

/*
算法解析：
1. 问题转换：将"添加+/-号使得结果等于target"转换为"选择部分数字使其和等于特定值"
2. 数学推导：通过P-N=target和P+N=sum，得出N=(sum-target)/2
3. 动态规划：使用二维DP数组求解"背包问题"的变种
4. 时间复杂度：O(n * neg)，其中neg = (sum-target)/2
5. 空间复杂度：O(n * neg)

示例：
nums = [1,1,1,1,1], target = 3
sum = 5, diff = 2, neg = 1
需要找出选择哪些数字使其和为1，然后这些数字添加负号
*/
```

#### [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/)

给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。

请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。

如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

 

**示例 1：**

```
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
```

**示例 2：**

```
输入：strs = ["10", "0", "1"], m = 1, n = 1
输出：2
解释：最大的子集是 {"0", "1"} ，所以答案是 2 。
```

 

**提示：**

- `1 <= strs.length <= 600`
- `1 <= strs[i].length <= 100`
- `strs[i]` 仅由 `'0'` 和 `'1'` 组成
- `1 <= m, n <= 100`

##### 实现

```java

```
##### 
