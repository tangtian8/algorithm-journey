# 20250808

#### [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

 

**示例 1：**

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2：**

```
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

 

**提示：**

- `1 <= intervals.length <= 104`
- `intervals[i].length == 2`
- `0 <= starti <= endi <= 104`

##### 实现

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals,(p,q)->p[0] - q[0]);
        List<int[]> ans = new ArrayList<>();
        for(int i = 0; i < intervals.length; i++){
            int l = intervals[i][0],r = intervals[i][1];
            if(ans.size() == 0 || ans.get(ans.size() - 1)[1] < l){
                ans.add(new int[]{l,r});
            }else{
                ans.get(ans.size() - 1)[1] = Math.max(ans.get(ans.size() - 1)[1],r);
            }
        }
        return ans.toArray(new int[ans.size()][]);
    }
}
```

#### [738. 单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/)

当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是**单调递增**的。

给定一个整数 `n` ，返回 *小于或等于 `n` 的最大数字，且数字呈 **单调递增*** 。

 

**示例 1:**

```
输入: n = 10
输出: 9
```

**示例 2:**

```
输入: n = 1234
输出: 1234
```

**示例 3:**

```
输入: n = 332
输出: 299
```

 

**提示:**

- `0 <= n <= 109`

##### 实现



```java
class Solution {
    public int monotoneIncreasingDigits(int n) {
       char[] starN = Integer.toString(n).toCharArray();
       int i = 1;
       while( i < starN.length && starN[i - 1] <= starN[i]){
         i+=1;
       } 
       if(i < starN.length){
        while(i > 0 && starN[i - 1] > starN[i]){
            starN[i - 1] -=1;
            i -= 1;
        }

        for(i += 1; i < starN.length; i++){
            starN[i] = '9';
        }
       }
       return Integer.parseInt(new String(starN));
    }
}
```

#### [968. 监控二叉树](https://leetcode.cn/problems/binary-tree-cameras/)

给定一个二叉树，我们在树的节点上安装摄像头。

节点上的每个摄影头都可以监视**其父对象、自身及其直接子对象。**

计算监控树的所有节点所需的最小摄像头数量。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png)

```
输入：[0,0,null,0,0]
输出：1
解释：如图所示，一台摄像头足以监控所有节点。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png)

```
输入：[0,0,null,0,null,0,null,null,0]
输出：2
解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。
```


**提示：**

1. 给定树的节点数的范围是 `[1, 1000]`。
2. 每个节点的值都是 0。

##### 实现

```java

```
