# 20250814

#### 完全背包

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

|       | 重量 | 价值 |
| ----- | ---- | ---- |
| 物品0 | 1    | 15   |
| 物品1 | 3    | 20   |
| 物品2 | 4    | 30   |

##### 实现

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int bagWeight = scanner.nextInt();

        int[] weight = new int[n];
        int[] value = new int[n];

        for (int i = 0; i < n; i++) {
            weight[i] = scanner.nextInt();
            value[i] = scanner.nextInt();
        }

        int[][] dp = new int[n][bagWeight + 1];

        for (int j = weight[0]; j <= bagWeight; j++) {
            dp[0][j] = dp[0][j - weight[0]] + value[0];
        }
        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= bagWeight; j++) {
                if (j < weight[i]) {
                    dp[i][j] = dp[i - 1][j];
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - weight[i]] + value[i]);
                }
            }
        }

        System.out.println(dp[n - 1][bagWeight]);
        scanner.close();
    }
}

```

#### [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

 

**示例 1：**

```
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

**示例 2：**

```
输入：amount = 3, coins = [2]
输出：0
解释：只用面额 2 的硬币不能凑成总金额 3 。
```

**示例 3：**

```
输入：amount = 10, coins = [10] 
输出：1
```

 

**提示：**

- `1 <= coins.length <= 300`
- `1 <= coins[i] <= 5000`
- `coins` 中的所有值 **互不相同**
- `0 <= amount <= 5000`

##### 实现

```java
class Solution {
    public int change(int amount, int[] coins) {
       int n = coins.length;
       int[][] f = new int[n + 1][amount + 1];
       f[0][0] = 1;
      //求组合数
       for(int i = 0; i < n; i++){
        for(int c = 0; c <= amount; c++){
            if(c < coins[i]){
                f[i+1][c] = f[i][c];
            }else{
                f[i + 1][c] = f[i][c] + f[i+ 1][c-coins[i]];
            }
        }
       } 
       return f[n][amount];
    }
}
```

#### [377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)

给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

 

**示例 1：**

```
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```

**示例 2：**

```
输入：nums = [9], target = 3
输出：0
```

 

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 1000`
- `nums` 中的所有元素 **互不相同**
- `1 <= target <= 1000`

##### 实现

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
     int[] dp = new int[target + 1];
        dp[0] = 1;
        
         //求排练数
        for (int i = 1; i <= target; i++) {
            for (int num : nums) {
                if (num <= i) {
                    dp[i] += dp[i - num];
                }
            }
        }
        return dp[target];
    }
}
```
#### [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

 

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**示例 2：**

```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```
##### 实现

```java


```







## 核心区别总结

### 1. **二维DP的区别**

java

```java
// 0-1背包
dp[i][w] = Math.max(dp[i-1][w], dp[i-1][w-weight] + value);
//                      ↑ i-1: 不能重复使用当前物品

// 完全背包  
dp[i][w] = Math.max(dp[i-1][w], dp[i][w-weight] + value);
//                      ↑ i: 可以重复使用当前物品
```

### 2. **一维DP的区别（关键！）**

java

```java
// 0-1背包：逆序遍历
for (int i = 0; i < n; i++) {
    for (int w = capacity; w >= weights[i]; w--) { // 逆序！
        dp[w] = Math.max(dp[w], dp[w-weights[i]] + values[i]);
    }
}

// 完全背包：正序遍历
for (int i = 0; i < n; i++) {
    for (int w = weights[i]; w <= capacity; w++) { // 正序！
        dp[w] = Math.max(dp[w], dp[w-weights[i]] + values[i]);
    }
}
```

### 3. **为什么循环顺序不同？**

**0-1背包逆序的原因：**

- 逆序保证计算`dp[w]`时，`dp[w-weight]`还是**上一轮**的值
- 这样避免了同一个物品被重复使用

**完全背包正序的原因：**

- 正序允许计算`dp[w]`时，`dp[w-weight]`是**本轮**更新的值
- 这样实现了同一个物品的重复使用

### 4. **记忆口诀**

- **0-1背包**：每个物品**只用一次** → **逆序**遍历容量
- **完全背包**：每个物品**无限使用** → **正序**遍历容量

### 5. **实际应用区别**

- **0-1背包**：选股票、选课程、装箱问题（每个物品唯一）
- **完全背包**：硬币兑换、爬楼梯、组合总和（物品可重复）

这个循环顺序的差异是面试中的**高频考点**，必须牢记！
