# 20250902

#### [684. 冗余连接](https://leetcode.cn/problems/redundant-connection/)

树可以看成是一个连通且 **无环** 的 **无向** 图。

给定一个图，该图从一棵 `n` 个节点 (节点值 `1～n`) 的树中添加一条边后获得。添加的边的两个不同顶点编号在 `1` 到 `n` 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 `n` 的二维数组 `edges` ，`edges[i] = [ai, bi]` 表示图中在 `ai` 和 `bi` 之间存在一条边。

请找出一条可以删去的边，删除后可使得剩余部分是一个有着 `n` 个节点的树。如果有多个答案，则返回数组 `edges` 中最后出现的那个。

 

**示例 1：**

![img](https://pic.leetcode-cn.com/1626676174-hOEVUL-image.png)

```
输入: edges = [[1,2], [1,3], [2,3]]
输出: [2,3]
```

**示例 2：**

![img](https://pic.leetcode-cn.com/1626676179-kGxcmu-image.png)

```
输入: edges = [[1,2], [2,3], [3,4], [1,4], [1,5]]
输出: [1,4]
```

 

**提示:**

- `n == edges.length`
- `3 <= n <= 1000`
- `edges[i].length == 2`
- `1 <= ai < bi <= edges.length`
- `ai != bi`
- `edges` 中无重复元素
- 给定的图是连通的 

##### 实现

```java
/**
 * 查找冗余连接的解决方案
 * 
 * 问题描述：给定一个无向图的边列表，找出一条可以删除的边，使得删除后的图仍然是一棵树
 * 解法思路：使用并查集(Union-Find)数据结构，当遇到两个已经连通的节点时，说明这条边是冗余的
 */
class Solution {
    /**
     * 查找冗余连接的主方法
     * 
     * @param edges 边的数组，每个元素是一个包含两个节点的数组
     * @return 需要删除的冗余边
     */
    public int[] findRedundantConnection(int[][] edges) {
        int n = edges.length;
        
        // 初始化并查集的parent数组
        // parent[i] = i 表示节点i的父节点是自己（即每个节点初始时都是独立的集合）
        int[] parent = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            parent[i] = i;  // 每个节点的父节点初始化为自己
        }
        
        // 遍历每一条边
        for (int i = 0; i < n; i++) {
            int[] edge = edges[i];
            int node1 = edge[0], node2 = edge[1];
            
            // 查找两个节点的根节点
            // 如果两个节点的根节点不同，说明它们不在同一个连通分量中
            if (find(parent, node1) != find(parent, node2)) {
                // 将两个节点合并到同一个集合中
                union(parent, node1, node2);
            } else {
                // 如果两个节点已经在同一个连通分量中，
                // 那么这条边就是冗余的，直接返回
                return edge;
            }
        }
        
        // 理论上不会执行到这里，因为题目保证存在冗余连接
        return new int[0];
    }
    
    /**
     * 合并两个节点到同一个集合
     * 
     * @param parent 并查集的parent数组
     * @param index1 第一个节点
     * @param index2 第二个节点
     */
    public void union(int[] parent, int index1, int index2) {
        // 找到两个节点的根节点，然后将第一个根节点的父节点设为第二个根节点
        // 这样就将两个集合合并了
        parent[find(parent, index1)] = find(parent, index2);
    }
    
    /**
     * 查找节点的根节点（带路径压缩优化）
     * 
     * @param parent 并查集的parent数组
     * @param index 要查找根节点的节点
     * @return 该节点的根节点
     */
    public int find(int[] parent, int index) {
        // 如果当前节点不是根节点（父节点不是自己）
        if (parent[index] != index) {
            // 递归查找根节点，并进行路径压缩
            // 路径压缩：将路径上的所有节点直接连接到根节点，优化后续查找效率
            parent[index] = find(parent, parent[index]);
        }
        // 返回根节点
        return parent[index];
    }
}

/**
 * 算法复杂度：
 * - 时间复杂度：O(n * α(n))，其中α是阿克曼函数的反函数，实际上接近O(n)
 * - 空间复杂度：O(n)，用于存储并查集的parent数组
 * 
 * 算法原理：
 * 1. 并查集维护了图中各个连通分量的信息
 * 2. 当处理每条边时，检查两个端点是否已经连通
 * 3. 如果未连通，则合并它们；如果已连通，则这条边就是冗余的
 * 4. 题目要求返回最后出现的冗余边，所以按顺序处理边，找到第一个冗余边即可返回
 */
```

#### [685. 冗余连接 II](https://leetcode.cn/problems/redundant-connection-ii/)

在本问题中，有根树指满足以下条件的 **有向** 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。

输入一个有向图，该图由一个有着 `n` 个节点（节点值不重复，从 `1` 到 `n`）的树及一条附加的有向边构成。附加的边包含在 `1` 到 `n` 中的两个不同顶点间，这条附加的边不属于树中已存在的边。

结果图是一个以边组成的二维数组 `edges` 。 每个元素是一对 `[ui, vi]`，用以表示 **有向** 图中连接顶点 `ui` 和顶点 `vi` 的边，其中 `ui` 是 `vi` 的一个父节点。

返回一条能删除的边，使得剩下的图是有 `n` 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/12/20/graph1.jpg)

```
输入：edges = [[1,2],[1,3],[2,3]]
输出：[2,3]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/12/20/graph2.jpg)

```
输入：edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]
输出：[4,1]
```

 

**提示：**

- `n == edges.length`
- `3 <= n <= 1000`
- `edges[i].length == 2`
- `1 <= ui, vi <= n`

##### 实现

```java
/**
 * 查找有向图中冗余连接的解决方案
 * 
 * 问题描述：给定一个有向图的边列表，图中有一条多余的边，找出并删除这条边，
 *         使得删除后的图是一个有根树（每个节点有且仅有一个父节点，除了根节点）
 * 
 * 关键概念：
 * - conflict: 某个节点有两个父节点的情况
 * - cycle: 图中存在环的情况
 * 
 * 可能的情况：
 * 1. 只有conflict，无cycle：删除后添加的冲突边
 * 2. 只有cycle，无conflict：删除导致环的边
 * 3. 既有conflict又有cycle：删除导致冲突节点产生环的那条边
 */
class Solution {
    /**
     * 查找有向图中的冗余连接
     * 
     * @param edges 有向边的数组，每个元素是[from, to]
     * @return 需要删除的冗余边
     */
    public int[] findRedundantDirectedConnection(int[][] edges) {
        int n = edges.length;
        UnionFind uf = new UnionFind(n + 1);
        
        // parent数组用于记录每个节点的父节点
        // parent[i] = i 表示节点i还没有父节点
        int[] parent = new int[n + 1];
        for (int i = 1; i <= n; ++i) {
            parent[i] = i;  // 初始化每个节点的父节点为自己
        }
        
        int conflict = -1;  // 记录产生冲突的边的索引（某节点有两个父节点）
        int cycle = -1;     // 记录产生环的边的索引
        
        // 遍历每一条边，检测冲突和环
        for (int i = 0; i < n; ++i) {
            int[] edge = edges[i];
            int node1 = edge[0], node2 = edge[1];  // node1 -> node2
            
            // 检查是否存在冲突：node2已经有父节点了
            if (parent[node2] != node2) {
                // node2已经有父节点，现在又要添加一个父节点node1，产生冲突
                conflict = i;
            } else {
                // node2还没有父节点，将node1设为node2的父节点
                parent[node2] = node1;
                
                // 检查是否会产生环
                // 如果node1和node2在并查集中已经连通，说明添加这条边会产生环
                if (uf.find(node1) == uf.find(node2)) {
                    cycle = i;  // 记录产生环的边
                } else {
                    // 没有产生环，将两个节点在并查集中合并
                    uf.union(node1, node2);
                }
            }
        }
        
        // 根据冲突和环的情况决定删除哪条边
        if (conflict < 0) {
            // 情况1：没有冲突，只有环
            // 直接返回导致环的边
            int[] redundant = {edges[cycle][0], edges[cycle][1]};
            return redundant;
        } else {
            // 情况2：有冲突
            int[] conflictEdge = edges[conflict];
            
            if (cycle >= 0) {
                // 情况3：既有冲突又有环
                // 需要删除的是导致冲突节点产生环的那条边
                // 即冲突节点的第一个父节点到冲突节点的边
                int[] redundant = {parent[conflictEdge[1]], conflictEdge[1]};
                return redundant;
            } else {
                // 情况2：只有冲突，没有环
                // 删除后添加的冲突边（当前的conflict边）
                int[] redundant = {conflictEdge[0], conflictEdge[1]};
                return redundant;
            }
        }
    }
}

/**
 * 并查集数据结构
 * 用于高效地判断两个元素是否在同一个集合中，以及合并两个集合
 */
class UnionFind {
    int[] ancestor;  // ancestor[i]表示节点i的祖先节点
    
    /**
     * 构造函数：初始化并查集
     * 
     * @param n 节点数量
     */
    public UnionFind(int n) {
        ancestor = new int[n];
        // 初始化：每个节点的祖先都是自己
        for (int i = 0; i < n; ++i) {
            ancestor[i] = i;
        }
    }
    
    /**
     * 合并两个节点所在的集合
     * 
     * @param index1 第一个节点
     * @param index2 第二个节点
     */
    public void union(int index1, int index2) {
        // 将index1的根节点的父节点设为index2的根节点
        // 从而将两个集合合并
        ancestor[find(index1)] = find(index2);
    }
    
    /**
     * 查找节点的根节点（带路径压缩优化）
     * 
     * @param index 要查找根节点的节点
     * @return 该节点的根节点
     */
    public int find(int index) {
        // 如果当前节点不是根节点
        if (ancestor[index] != index) {
            // 递归查找根节点，并进行路径压缩
            // 路径压缩：将路径上的所有节点直接连接到根节点，优化后续查找效率
            ancestor[index] = find(ancestor[index]);
        }
        return ancestor[index];
    }
}

/**
 * 算法总结：
 * 
 * 时间复杂度：O(n * α(n))，其中α是阿克曼函数的反函数，实际接近O(n)
 * 空间复杂度：O(n)，用于并查集和parent数组
 * 
 * 核心思想：
 * 1. 使用parent数组检测冲突（某节点有多个父节点）
 * 2. 使用并查集检测环（两个已连通的节点再次连接）
 * 3. 根据冲突和环的组合情况，决定删除哪条边：
 *    - 无冲突有环：删除导致环的边
 *    - 有冲突无环：删除后添加的冲突边
 *    - 有冲突有环：删除导致冲突节点环的第一条边
 * 
 * 这是LeetCode 685题的解法，比无向图的版本更复杂，需要同时处理冲突和环两种情况。
 */
```
